name: OpenFrame Build Container Images

permissions:
  contents: write
  packages: write
  actions: write
  pull-requests: write
  attestations: write
  id-token: write

on:
  pull_request:
    types: [closed]
    branches: [main]

env:
  ORGANIZATION: flamingo-cx
  REGISTRY: ghcr.io
  GH_TOKEN: ${{ github.token }}

jobs:
  wait-for-java:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for Java build
        uses: actions/github-script@v7
        with:
          script: |
            const maxAttempts = 40; // 20 minutes
            const interval = 30000; // 30 seconds
            let attempts = 0;

            while (attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'build-java.yml',
                branch: context.payload.pull_request.base.ref,
                per_page: 10
              });

              if (runs.data.workflow_runs.length === 0) {
                console.log('No workflow runs found');
                process.exit(1);
              }

              // Find the most recent run that was triggered by the same PR
              const currentPR = context.payload.pull_request.number;
              const relevantRun = runs.data.workflow_runs.find(run =>
                run.pull_requests &&
                run.pull_requests.some(pr => pr.number === currentPR)
              );

              if (!relevantRun) {
                console.log('No workflow run found for this PR');
                process.exit(1);
              }

              console.log(`Status: ${relevantRun.status}`);
              console.log(`Conclusion: ${relevantRun.conclusion}`);
              console.log(`Head Branch: ${relevantRun.head_branch}`);

              if (relevantRun.status === 'completed') {
                if (relevantRun.conclusion === 'success') {
                  console.log('Java build completed successfully');
                  process.exit(0);
                } else if (relevantRun.conclusion === 'failure') {
                  console.log('Java build failed');
                  process.exit(1);
                } else if (relevantRun.conclusion === 'cancelled') {
                  console.log('Java build was cancelled');
                  process.exit(1);
                }
              }

              console.log(`Waiting for Java build to complete... (30 seconds)`);
              await new Promise(resolve => setTimeout(resolve, interval));
              attempts++;
            }

            console.log('Timeout waiting for Java build to complete');
            process.exit(1);

  build:
    needs: wait-for-java
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Disable fail-fast behavior
      matrix:
        service: [
          { name: 'mongodb', path: './infrastructure/mongodb/' },
          { name: 'cassandra', path: './infrastructure/cassandra/' },
          { name: 'nifi', path: './infrastructure/nifi/' },
          { name: 'postgresql', path: './infrastructure/postgresql/' },
          { name: 'tactical-base', path: './infrastructure/tactical-rmm/tactical-base/', context: './infrastructure/tactical-rmm' },
          { name: 'tactical-frontend', path: './infrastructure/tactical-rmm/tactical-frontend/', context: './infrastructure/tactical-rmm' },
          { name: 'tactical-nginx', path: './infrastructure/tactical-rmm/tactical-nginx/', context: './infrastructure/tactical-rmm' },
          { name: 'tactical-backend', path: './infrastructure/tactical-rmm/tactical-base/', context: './infrastructure/tactical-rmm' },
          { name: 'tactical-nats', path: './infrastructure/tactical-rmm/tactical-base/', context: './infrastructure/tactical-rmm' },
          { name: 'tactical-websockets', path: './infrastructure/tactical-rmm/tactical-base/', context: './infrastructure/tactical-rmm' },
          { name: 'tactical-celery', path: './infrastructure/tactical-rmm/tactical-base/', context: './infrastructure/tactical-rmm' },
          { name: 'tactical-celerybeat', path: './infrastructure/tactical-rmm/tactical-base/', context: './infrastructure/tactical-rmm' },
          { name: 'fleetmdm', path: './infrastructure/fleetmdm/', context: './infrastructure/fleetmdm' },
          { name: 'core', path: './libs/openframe-core/' },
          { name: 'data', path: './libs/openframe-data/' },
          { name: 'api', path: './services/openframe-api/' },
          { name: 'config', path: './services/openframe-config/' },
          { name: 'gateway', path: './services/openframe-gateway/' },
          { name: 'management', path: './services/openframe-management/' },
          { name: 'stream', path: './services/openframe-stream/' },
          { name: 'ui', path: './services/openframe-ui/' },
          { name: 'meshcentral', path: './infrastructure/meshcentral/server/' },
          { name: 'meshcentral-nginx', path: './infrastructure/meshcentral/nginx/' }
        ]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up environment
        run: |
          echo "TIMESTAMP=$(date +%s)" >> $GITHUB_ENV
          echo "TIMESTAMP_TAG=$(date +%d%m%Y%H%M)" >> $GITHUB_ENV
          echo "COMMIT_SHA=${GITHUB_SHA::8}" >> $GITHUB_ENV

      # Get the latest successful Java build artifacts
      - name: Download Java artifacts
        run: |
          # Get the latest successful run ID
          RUN_ID=$(gh api repos/${{ github.repository }}/actions/workflows/build-java.yml/runs --jq '.workflow_runs[0].id')

          # Download artifacts from that run
          gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts --jq '.artifacts[].id' | while read -r artifact_id; do
            gh api repos/${{ github.repository }}/actions/artifacts/$artifact_id/zip -H "Accept: application/vnd.github.v3+json" --output artifact.zip
            unzip artifact.zip
            rm artifact.zip
          done

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image
        id: docker_build
        run: |
          # Set build context
          BUILD_CONTEXT="${{ matrix.service.context || matrix.service.path }}"

          # Build and push the image
          docker buildx build \
            --platform linux/amd64 \
            --push \
            --file "${{ matrix.service.path }}Dockerfile" \
            --tag "${{ env.REGISTRY }}/${{ env.ORGANIZATION }}/openframe-${{ matrix.service.name }}:latest" \
            --tag "${{ env.REGISTRY }}/${{ env.ORGANIZATION }}/openframe-${{ matrix.service.name }}:${{ env.COMMIT_SHA }}" \
            --tag "${{ env.REGISTRY }}/${{ env.ORGANIZATION }}/openframe-${{ matrix.service.name }}:${{ env.TIMESTAMP_TAG }}" \
            --cache-from "type=gha" \
            --cache-to "type=gha,mode=max" \
            --provenance=true \
            "$BUILD_CONTEXT"

      # Clean up old versions after successful push
      - name: Clean up old versions
        if: success() && steps.docker_build.outcome == 'success'
        env:
          GITHUB_TOKEN_CLASSIC: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x ./kind-cluster/scripts/gh-packages.sh
          # Keep latest, commit SHA, and timestamp tags
          ./kind-cluster/scripts/gh-packages.sh --delete-old "openframe-${{ matrix.service.name }}" \
            "latest" \
            "${{ env.COMMIT_SHA }}" \
            "${{ env.TIMESTAMP_TAG }}"
        continue-on-error: true
