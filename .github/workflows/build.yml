name: OpenFrame Build and Push Latest

permissions:
  contents: write
  packages: write
  actions: write
  pull-requests: write
  attestations: write
  id-token: write

on:
  push:
    branches: [main]
    paths:
      - 'manifests/**'
      - 'openframe/**'
      - 'integrated-tools/**'
      - 'pom.xml'
  # üöÄ MANUAL TRIGGER: Force rebuild all images from GitHub UI
  workflow_dispatch:
    inputs:
      force_all_builds:
        description: 'Force build all images (ignores change detection)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

env:
  REGISTRY: "ghcr.io"
  # üöÄ DYNAMIC: Auto-detects org and repo from GitHub context
  ORGANISATION: ${{ github.repository_owner }}
  REPOSITORY: ${{ github.event.repository.name }}
  # üéØ BULLETPROOF: Repository-based image visibility
  REPO_NAME: ${{ github.repository }}
  IMAGE_VISIBILITY: ${{ (contains(github.repository, '-oss-') && 'public') || (contains(github.repository, 'oss') && 'public') || (contains(github.repository, '-saas-') && 'private') || (contains(github.repository, 'saas') && 'private') || 'private' }}
  # üî• FORCE BUILD: Manual trigger to build all images
  FORCE_ALL_BUILDS: ${{ github.event.inputs.force_all_builds == 'true' }}

jobs:

  changes:
    name: Changes
    uses: ./.github/workflows/changes.yml
    with:
      force_all_builds: ${{ github.event.inputs.force_all_builds || 'false' }}

  matrix:
    name: Matrix
    uses: ./.github/workflows/matrix.yml

  build_java:
    name: "Build Java: ${{ matrix.name }}"
    needs: [changes, matrix]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.matrix.outputs.matrix_java) }}
    steps:
      - name: Checkout
        if: contains(needs.changes.outputs[matrix.name], 'true')
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Maven Central Repository with JDK 21
        if: contains(needs.changes.outputs[matrix.name], 'true')
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven'
          cache-dependency-path: |
            ${{ matrix.path }}/pom.xml
            **/pom.xml
          check-latest: true

      - name: Cache Maven packages
        if: contains(needs.changes.outputs[matrix.name], 'true')
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ${{ matrix.path }}/target
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build with Maven
        if: contains(needs.changes.outputs[matrix.name], 'true')
        run: mvn clean install -pl ${{ matrix.path }} -am -Dcompress

      - name: Upload Java artifacts
        if: contains(needs.changes.outputs[matrix.name], 'true')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: |
            ${{ matrix.path }}/target/*.jar
            !${{ matrix.path }}/target/original-*.jar
            !${{ matrix.path }}/target/*-sources.jar
            !${{ matrix.path }}/target/*-javadoc.jar
          retention-days: 1


  build:
    name: "Build image: ${{ matrix.name }}"
    needs: [build_java, matrix, changes]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.matrix.outputs.matrix) }}
    steps:
      - name: Checkout
        if: contains(needs.changes.outputs[matrix.name], 'true')
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Download Java artifacts
        if: contains(fromJSON(toJSON(matrix.type)), 'java') && matrix.artifact_name != '' && contains(needs.changes.outputs[matrix.name], 'true')
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.path }}/target

      - name: Log in to GitHub Container Registry
        if: contains(needs.changes.outputs[matrix.name], 'true')
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        if: contains(needs.changes.outputs[matrix.name], 'true')
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ matrix.name == 'fleetmdm' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}

      - name: Set up Docker Buildx
        if: contains(needs.changes.outputs[matrix.name], 'true')
        uses: docker/setup-buildx-action@v3

      - name: Convert organization to lowercase
        if: contains(needs.changes.outputs[matrix.name], 'true')
        id: lowercase
        run: |
          echo "org_lower=$(echo '${{ env.ORGANISATION }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT
          echo "repo_lower=$(echo '${{ env.REPOSITORY }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Generate metadata
        if: contains(needs.changes.outputs[matrix.name], 'true')
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.lowercase.outputs.org_lower }}/${{ steps.lowercase.outputs.repo_lower }}/${{ matrix.name }}
          tags: |
            type=ref,event=tag
            type=raw,value=${{ needs.changes.outputs.commit_sha }}
            type=raw,value=${{ needs.changes.outputs.timestamp_tag }}
            type=raw,value=latest
          labels: |
            org.opencontainers.image.vendor=${{ steps.lowercase.outputs.org_lower }}
            org.opencontainers.image.description=OpenFrame is a platform for building and deploying AI agents.
            org.opencontainers.image.licenses=Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)

      - name: Format build arguments
        if: contains(needs.changes.outputs[matrix.name], 'true')
        id: format_args
        uses: ./.github/steps/docker-format-build-args
        with:
          build_args: ${{ toJSON(matrix.build_args) }}
        env:
          BUILD_ARGS: ${{ steps.format_args.outputs.formatted_args }}

      - name: Build and push image
        if: contains(needs.changes.outputs[matrix.name], 'true')
        id: docker_build
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context || matrix.path }}
          file: ${{ matrix.path }}/Dockerfile
          platforms: ${{ matrix.name == 'fleetmdm' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}
          push: true
          provenance: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            ${{ env.BUILD_ARGS }}

      - name: Set image visibility based on repository name  
        if: contains(needs.changes.outputs[matrix.name], 'true') && steps.docker_build.outcome == 'success'
        continue-on-error: true
        run: |
          echo "üè∑Ô∏è Repository: ${{ env.REPO_NAME }}"
          echo "üéØ Setting ${{ matrix.name }} visibility to: ${{ env.IMAGE_VISIBILITY }}"
          
          # Only proceed if we want to make it public
          if [[ "${{ env.IMAGE_VISIBILITY }}" == "public" ]]; then
            echo "‚è≥ Waiting for package to be available in registry..."
            sleep 20
            
            # Package name - try both organization and user endpoints
            PACKAGE_NAME="${{ env.REPOSITORY }}%2F${{ matrix.name }}"
            echo "üì¶ Encoded package name: ${PACKAGE_NAME}"
            
            # Convert to lowercase for API calls
            ORG_LOWER=$(echo "${{ env.ORGANISATION }}" | tr '[:upper:]' '[:lower:]')
            REPO_LOWER=$(echo "${{ env.REPOSITORY }}" | tr '[:upper:]' '[:lower:]')
            
            # First, check if package exists in organization packages (use lowercase org name)
            echo "üîç Checking if package exists in organization (${ORG_LOWER})..."
            ORG_PACKAGE_CHECK=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/orgs/${ORG_LOWER}/packages/container/${PACKAGE_NAME}" 2>&1)
            
            # Also check user packages
            echo "üîç Checking if package exists in user packages..."
            USER_PACKAGE_CHECK=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/user/packages/container/${PACKAGE_NAME}" 2>&1)
            
            # Determine package ownership
            PACKAGE_ENDPOINT=""
            if [[ ! "$ORG_PACKAGE_CHECK" =~ "Not Found" ]] && [[ ! "$ORG_PACKAGE_CHECK" =~ "404" ]]; then
              echo "‚úÖ Package found in organization packages"
              PACKAGE_ENDPOINT="orgs/${ORG_LOWER}"
              echo "üîß Using lowercase org name: ${ORG_LOWER}"
            elif [[ ! "$USER_PACKAGE_CHECK" =~ "Not Found" ]] && [[ ! "$USER_PACKAGE_CHECK" =~ "404" ]]; then
              echo "‚úÖ Package found in user packages"
              PACKAGE_ENDPOINT="user"
            else
              echo "‚ö†Ô∏è Package not found in either location, will try all methods"
              PACKAGE_ENDPOINT="orgs/${ORG_LOWER}"  # Default to lowercase org
              echo "üîß Defaulting to lowercase org name: ${ORG_LOWER}"
            fi
            
            # BULLETPROOF METHOD 1: Try with detected endpoint
            echo "üîÑ Method 1: Using ${PACKAGE_ENDPOINT} endpoint..."
            METHOD1_RESPONSE=$(curl -s -X PATCH \
              -H "Accept: application/vnd.github.package-deletes-preview+json" \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -d '{"visibility":"public"}' \
              "https://api.github.com/${PACKAGE_ENDPOINT}/packages/container/${PACKAGE_NAME}" 2>&1)
            if echo "$METHOD1_RESPONSE" | grep -q '"visibility":\s*"public"'; then
              echo "‚úÖ SUCCESS: Package visibility set to public via ${PACKAGE_ENDPOINT} endpoint"
              echo "Response: $METHOD1_RESPONSE"
              exit 0
            else
              echo "‚ùå Method 1 failed: $METHOD1_RESPONSE"
            fi
            
            # BULLETPROOF METHOD 2: Try the visibility endpoint
            echo "üîÑ Method 2: Using ${PACKAGE_ENDPOINT} visibility endpoint..."
            METHOD2_RESPONSE=$(curl -s -X PATCH \
              -H "Accept: application/vnd.github.package-deletes-preview+json" \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -d '{"visibility":"public"}' \
              "https://api.github.com/${PACKAGE_ENDPOINT}/packages/container/${PACKAGE_NAME}/visibility" 2>&1)
            if echo "$METHOD2_RESPONSE" | grep -q '"visibility":\s*"public"'; then
              echo "‚úÖ SUCCESS: Package visibility set to public via ${PACKAGE_ENDPOINT} visibility endpoint"
              echo "Response: $METHOD2_RESPONSE"
              exit 0
            else
              echo "‚ùå Method 2 failed: $METHOD2_RESPONSE"
            fi
            
            # BULLETPROOF METHOD 3: Try without URL encoding
            echo "üîÑ Method 3: Trying ${PACKAGE_ENDPOINT} without URL encoding..."
            SIMPLE_PACKAGE_NAME="${{ env.REPOSITORY }}/${{ matrix.name }}"
            METHOD3_RESPONSE=$(curl -s -X PATCH \
              -H "Accept: application/vnd.github.package-deletes-preview+json" \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -d '{"visibility":"public"}' \
              "https://api.github.com/${PACKAGE_ENDPOINT}/packages/container/${SIMPLE_PACKAGE_NAME}" 2>&1)
            if echo "$METHOD3_RESPONSE" | grep -q '"visibility":\s*"public"'; then
              echo "‚úÖ SUCCESS: Package visibility set to public without URL encoding"
              echo "Response: $METHOD3_RESPONSE"
              exit 0
            else
              echo "‚ùå Method 3 failed: $METHOD3_RESPONSE"
            fi
            
            # BULLETPROOF METHOD 4: Use GitHub CLI with detected endpoint
            echo "üîÑ Method 4: Using GitHub CLI with ${PACKAGE_ENDPOINT} endpoint..."
            METHOD4_RESPONSE=$(gh api --method PATCH \
              --header "Accept: application/vnd.github.package-deletes-preview+json" \
              --header "X-GitHub-Api-Version: 2022-11-28" \
              --field visibility=public \
              "/${PACKAGE_ENDPOINT}/packages/container/${PACKAGE_NAME}" 2>&1)
            if echo "$METHOD4_RESPONSE" | grep -q '"visibility":\s*"public"'; then
              echo "‚úÖ SUCCESS: Package visibility set to public via GitHub CLI"
              echo "Response: $METHOD4_RESPONSE"
              exit 0
            else
              echo "‚ùå Method 4 failed: $METHOD4_RESPONSE"
            fi
            
            # GitHub API limitation: Organization packages can't change visibility via API
            echo "‚ö†Ô∏è KNOWN LIMITATION: GitHub API does not support changing visibility for organization-owned packages"
            echo "üìã This is a GitHub API restriction, not a configuration error"
            echo ""
            echo "üîß SOLUTION: Package must be made public manually:"
            echo "1. Go to: https://github.com/orgs/${ORG_LOWER}/packages"
            echo "2. Find package: ${REPO_LOWER}/${{ matrix.name }}"
            echo "3. Click 'Package settings' ‚Üí 'Change visibility' ‚Üí 'Public'"
            echo ""
            echo "üîó Direct link: https://github.com/orgs/${ORG_LOWER}/packages/container/${REPO_LOWER}%2F${{ matrix.name }}"
            echo ""
            echo "‚ÑπÔ∏è  Alternative: Use Personal Access Token instead of GITHUB_TOKEN to create user-owned packages"
            echo "   User-owned packages support API visibility changes, organization-owned packages do not"
            
          else
            echo "‚ÑπÔ∏è  Package will remain private (repository doesn't match OSS naming pattern)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Delete old versions
        if: contains(needs.changes.outputs[matrix.name], 'true') && steps.docker_build.outcome == 'success'
        uses: dataaxiom/ghcr-cleanup-action@v1
        continue-on-error: true
        with:
          package: ${{ steps.lowercase.outputs.repo_lower }}/${{ matrix.name }}
          delete-ghost-images: true
          delete-tags: "*"
          exclude-tags: latest,${{ needs.changes.outputs.commit_sha }},${{ needs.changes.outputs.timestamp_tag }}
