name: OpenFrame CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
  workflow_dispatch:

env:
  ORGANIZATION: flamingo-cx
  TIMESTAMP: ${{ github.event.repository.updated_at }}
  COMMIT_SHA: ${{ github.sha }}

permissions:
  contents: write
  packages: write
  actions: write
  pull-requests: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: mvn -B package --file pom.xml

      - name: Upload artifacts
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: java-artifacts
          path: |
            **/target/*.jar
            !**/target/original-*.jar
            !**/target/*-sources.jar
            !**/target/*-javadoc.jar
          compression-level: 9
          retention-days: 1

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Set up Docker environment
        run: |
          # Clean up disk space
          docker system prune -af
          df -h
          
          # Set up buildx for better caching
          docker buildx create --use
          docker buildx inspect --bootstrap

      - name: Download artifacts
        if: github.ref == 'refs/heads/main'
        uses: actions/download-artifact@v4
        with:
          name: java-artifacts

      - name: Create target directories and copy JAR files
        run: |
          # Debug: List all JAR files
          echo "Found JAR files:"
          find . -name "*.jar" -ls

          # Create target directories and copy JARs
          for dir in $(find . -name "pom.xml" -exec dirname {} \;); do
            mkdir -p "$dir/target"
            echo "Created target directory for $dir"
            
            # Find JARs for this module
            module_name=$(basename "$dir")
            echo "Looking for JARs for module $module_name"
            
            # Try to find and copy the corresponding JAR
            for jar in $(find . -name "${module_name}*.jar"); do
              if [ -f "$jar" ]; then
                echo "Copying $jar to $dir/target/"
                cp "$jar" "$dir/target/"
              fi
            done
          done

          # Verify JAR placement
          echo "Final JAR locations:"
          find . -name "*.jar" -ls

      - name: Build infrastructure images
        run: |
          # Create Docker network
          docker network create openframe-network --label com.docker.compose.network=openframe-network || true
          
          # Build infrastructure images with buildx
          for service in mongodb cassandra nifi config api management ui stream gateway; do
            if [ -d "infrastructure/$service" ]; then
              service_dir="infrastructure/$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building infrastructure service $service..."
            elif [ -d "services/openframe-$service" ]; then
              service_dir="services/openframe-$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building OpenFrame service $service..."
            else
              echo "Error: Could not find build context for service $service"
              exit 1
            fi
            
            # Create temporary build context
            temp_context=$(mktemp -d)
            
            # Copy service files to build context
            cp -r "$service_dir"/* "$temp_context/"
            
            # If this is a Java service, ensure target directory exists and copy JARs
            if [ -f "$service_dir/pom.xml" ]; then
              mkdir -p "$temp_context/target"
              module_name=$(basename "$service_dir")
              echo "Looking for JARs for module $module_name in $service_dir/target/"
              if [ -d "$service_dir/target" ]; then
                echo "Contents of $service_dir/target/:"
                ls -la "$service_dir/target/"
                cp "$service_dir"/target/*.jar "$temp_context/target/" || true
              fi
              echo "Contents of temp context target directory:"
              ls -la "$temp_context/target/" || true
            fi
            
            # List files in build context for debugging
            echo "Contents of build context:"
            ls -la "$temp_context"
            if [ -d "$temp_context/target" ]; then
              echo "Contents of target directory:"
              ls -la "$temp_context/target"
            fi
            
            # Build the image
            if ! DOCKER_BUILDKIT=1 docker buildx build \
              --load \
              -t "openframe-$service:latest" \
              -f "$dockerfile" \
              --cache-from "type=local,src=/tmp/.buildx-cache" \
              --cache-to "type=local,dest=/tmp/.buildx-cache" \
              --no-cache \
              "$temp_context"; then
              echo "Error: Failed to build $service image"
              rm -rf "$temp_context"
              exit 1
            fi
            
            rm -rf "$temp_context"
          done

      - name: Deploy infrastructure services
        run: |
          docker compose -f docker-compose.openframe-infrastructure.yml up -d

      - name: Deploy Tactical RMM
        run: |
          docker compose -f docker-compose.openframe-tactical-rmm.yml up -d

      - name: Deploy Fleet MDM
        run: |
          docker compose -f docker-compose.openframe-fleet-mdm.yml up -d

      - name: Deploy Authentik
        run: |
          docker compose -f docker-compose.openframe-authentik.yml up -d

      - name: Register tools with OpenFrame API
        run: |
          echo "Registering tools with OpenFrame API..."
          # Add tool registration logic here

      - name: Verify deployment
        run: |
          ./scripts/test-public-endpoints.sh

      - name: Cleanup images and artifacts
        if: always()
        run: |
          echo "Cleaning up Docker images..."
          docker system prune -af
          
          echo "Cleaning up build artifacts..."
          find . -type f -name "*.jar" -delete
          find . -type d -name "target" -exec rm -rf {} +

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "Deployment failed, cleaning up services..."
          docker compose -f docker-compose.openframe-infrastructure.yml down
          docker compose -f docker-compose.openframe-tactical-rmm.yml down
          docker compose -f docker-compose.openframe-fleet-mdm.yml down
          docker compose -f docker-compose.openframe-authentik.yml down
          
          # Clean up any remaining images
          echo "Cleaning up remaining Docker images..."
          docker system prune -af
          
          echo "Cleanup completed"
