name: OpenFrame CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
  workflow_dispatch:

env:
  ORGANIZATION: flamingo-cx
  TIMESTAMP: ${{ github.event.repository.updated_at }}
  COMMIT_SHA: ${{ github.sha }}

permissions:
  contents: write
  packages: write
  actions: write
  pull-requests: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: |
          echo "Building with Maven..."
          mvn -B clean package --file pom.xml
          
          echo "Setting up JAR files..."
          mkdir -p /tmp/jars
          
          # Function to find and copy JAR files
          copy_jar() {
            local dir=$1
            local module_name=$(basename "$dir")
            echo "Processing module $module_name"
            
            # Find the JAR file (excluding original, sources, and javadoc JARs)
            local jar_file=$(find "$dir/target" -maxdepth 1 -name "*.jar" \
              ! -name "original-*.jar" \
              ! -name "*-sources.jar" \
              ! -name "*-javadoc.jar" \
              -type f | head -n 1)
            
            if [ -n "$jar_file" ]; then
              echo "Found JAR: $jar_file"
              cp "$jar_file" "/tmp/jars/${module_name}.jar"
              chmod 644 "/tmp/jars/${module_name}.jar"
              echo "Copied to /tmp/jars/${module_name}.jar"
              ls -l "/tmp/jars/${module_name}.jar"
            else
              echo "Error: No suitable JAR found for $module_name"
              echo "Contents of $dir/target:"
              ls -la "$dir/target/"
              return 1
            fi
          }
          
          # Process all modules
          echo "Processing all modules..."
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              if ! copy_jar "$dir"; then
                echo "Failed to process $dir"
                exit 1
              fi
            fi
          done
          
          echo "Final contents of /tmp/jars:"
          ls -la /tmp/jars/
          
          echo "Contents of centralized JAR directory:"
          ls -la /tmp/jars/

      - name: Verify JAR files
        run: |
          echo "Verifying JAR files..."
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              echo "=== Contents of $dir/target ==="
              ls -la "$dir/target/"*.jar || true
            fi
          done

      - name: Clean up old artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            for (const artifact of artifacts.data.artifacts) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id
              });
            }

      - name: Compress JAR files
        run: |
          cd /tmp/jars
          tar czf ../artifacts.tar.gz *.jar
          ls -lh ../artifacts.tar.gz

      - name: Upload JAR files
        uses: actions/upload-artifact@v4
        with:
          name: jar-files
          path: /tmp/artifacts.tar.gz
          retention-days: 1
          if-no-files-found: error

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Download JAR files
        uses: actions/download-artifact@v4
        with:
          name: jar-files
          path: /tmp

      - name: Extract JAR files
        run: |
          mkdir -p /tmp/jars
          cd /tmp
          tar xzf artifacts.tar.gz -C /tmp/jars/
          ls -la /tmp/jars/

      - name: Verify JAR files
        run: |
          echo "Creating /tmp/jars directory..."
          mkdir -p /tmp/jars
          
          echo "Contents of /tmp/jars after download:"
          ls -la /tmp/jars/
          
          # Verify required JARs exist
          missing_jars=0
          for module in api config gateway management stream core data; do
            if [ ! -f "/tmp/jars/openframe-${module}.jar" ]; then
              echo "Error: Missing JAR for openframe-${module}"
              missing_jars=1
            else
              echo "Found JAR for openframe-${module}:"
              ls -l "/tmp/jars/openframe-${module}.jar"
              file "/tmp/jars/openframe-${module}.jar"
            fi
          done
          
          if [ $missing_jars -eq 1 ]; then
            echo "Error: Some required JARs are missing"
            exit 1
          fi
          
          # Ensure correct permissions
          chmod 644 /tmp/jars/*.jar
          
          echo "JAR file details:"
          file /tmp/jars/*.jar || true

      - name: Set up Docker environment
        run: |
          echo "Setting up Docker environment..."
          # Clean up disk space
          docker system prune -af
          df -h
          
          # Set up buildx for better caching
          docker buildx create --use
          docker buildx inspect --bootstrap
          
          # Create Docker network
          docker network create openframe-network --label com.docker.compose.network=openframe-network || true

      - name: Build infrastructure images
        run: |
          echo "Building infrastructure images..."
          
          # Build infrastructure images with buildx
          for service in mongodb cassandra nifi config api management ui stream gateway; do
            if [ -d "infrastructure/$service" ]; then
              service_dir="infrastructure/$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building infrastructure service $service..."
            elif [ -d "services/openframe-$service" ]; then
              service_dir="services/openframe-$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building OpenFrame service $service..."
            else
              echo "Error: Could not find build context for service $service"
              exit 1
            fi
            
            # Create temporary build context
            temp_context=$(mktemp -d)
            
            # Copy service files to build context
            cp -r "$service_dir"/* "$temp_context/"
            
            # If this is a Java service, copy the appropriate JAR file
            if [ -f "$service_dir/pom.xml" ]; then
              mkdir -p "$temp_context/target"
              module_name=$(basename "$service_dir")
              echo "Looking for JAR for module $module_name"
              if [ -f "/tmp/jars/${module_name}.jar" ]; then
                echo "Found JAR for $module_name"
                cp "/tmp/jars/${module_name}.jar" "$temp_context/target/app.jar"
              else
                echo "Error: Could not find JAR for $module_name"
                exit 1
              fi
              echo "Contents of target directory:"
              ls -la "$temp_context/target/"
            fi
            
            # List files in build context for debugging
            echo "Contents of build context:"
            ls -la "$temp_context"
            if [ -d "$temp_context/target" ]; then
              echo "Contents of target directory:"
              ls -la "$temp_context/target"
            fi
            
            # Build the image
            if ! DOCKER_BUILDKIT=1 docker buildx build \
              --load \
              -t "openframe-$service:latest" \
              -f "$dockerfile" \
              --cache-from "type=local,src=/tmp/.buildx-cache" \
              --cache-to "type=local,dest=/tmp/.buildx-cache" \
              --no-cache \
              "$temp_context"; then
              echo "Error: Failed to build $service image"
              rm -rf "$temp_context"
              exit 1
            fi
            
            rm -rf "$temp_context"
          done

      - name: Deploy infrastructure services
        run: |
          docker compose -f docker-compose.openframe-infrastructure.yml up -d

      - name: Deploy Tactical RMM
        run: |
          docker compose -f docker-compose.openframe-tactical-rmm.yml up -d

      - name: Deploy Fleet MDM
        run: |
          docker compose -f docker-compose.openframe-fleet-mdm.yml up -d

      - name: Deploy Authentik
        run: |
          docker compose -f docker-compose.openframe-authentik.yml up -d

      - name: Register tools with OpenFrame API
        run: |
          echo "Registering tools with OpenFrame API..."
          # Add tool registration logic here

      - name: Verify deployment
        run: |
          ./scripts/test-public-endpoints.sh

      - name: Cleanup images and artifacts
        if: always()
        run: |
          echo "Cleaning up Docker images..."
          docker system prune -af
          
          echo "Cleaning up build artifacts..."
          find . -type f -name "*.jar" -delete
          find . -type d -name "target" -exec rm -rf {} +

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "Deployment failed, cleaning up services..."
          docker compose -f docker-compose.openframe-infrastructure.yml down
          docker compose -f docker-compose.openframe-tactical-rmm.yml down
          docker compose -f docker-compose.openframe-fleet-mdm.yml down
          docker compose -f docker-compose.openframe-authentik.yml down
          
          # Clean up any remaining images
          echo "Cleaning up remaining Docker images..."
          docker system prune -af
          
          echo "Cleanup completed"
