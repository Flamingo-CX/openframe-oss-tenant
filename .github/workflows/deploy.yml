name: OpenFrame CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
  workflow_dispatch:

env:
  ORGANIZATION: flamingo-cx
  TIMESTAMP: ${{ github.event.repository.updated_at }}
  COMMIT_SHA: ${{ github.sha }}

permissions:
  contents: write
  packages: write
  actions: write
  pull-requests: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: |
          echo "Building with Maven..."
          mvn -B clean package --file pom.xml
          
          echo "Setting up JAR files..."
          mkdir -p /tmp/jars
          
          # Function to find and copy JAR files
          copy_jar() {
            local dir=$1
            local module_name=$(basename "$dir")
            echo "Processing module $module_name"
            
            # Find the JAR file (excluding original, sources, and javadoc JARs)
            local jar_file=$(find "$dir/target" -maxdepth 1 -name "*.jar" \
              ! -name "original-*.jar" \
              ! -name "*-sources.jar" \
              ! -name "*-javadoc.jar" \
              -type f | head -n 1)
            
            if [ -n "$jar_file" ]; then
              echo "Found JAR: $jar_file"
              cp "$jar_file" "/tmp/jars/${module_name}.jar"
              chmod 644 "/tmp/jars/${module_name}.jar"
              echo "Copied to /tmp/jars/${module_name}.jar"
              ls -l "/tmp/jars/${module_name}.jar"
            else
              echo "Error: No suitable JAR found for $module_name"
              echo "Contents of $dir/target:"
              ls -la "$dir/target/"
              return 1
            fi
          }
          
          # Process all modules
          echo "Processing all modules..."
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              if ! copy_jar "$dir"; then
                echo "Failed to process $dir"
                exit 1
              fi
            fi
          done
          
          echo "Final contents of /tmp/jars:"
          ls -la /tmp/jars/
          
          echo "Contents of centralized JAR directory:"
          ls -la /tmp/jars/

      - name: Verify JAR files
        run: |
          echo "Verifying JAR files..."
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              echo "=== Contents of $dir/target ==="
              ls -la "$dir/target/"*.jar || true
            fi
          done

      - name: Prepare JAR files for build
        run: |
          echo "Preparing JAR files for build..."
          mkdir -p /tmp/jars
          
          # Copy JAR files to a central location
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              module_name=$(basename "$dir")
              jar_file=$(find "$dir/target" -maxdepth 1 -name "*.jar" \
                ! -name "original-*.jar" \
                ! -name "*-sources.jar" \
                ! -name "*-javadoc.jar" \
                -type f | head -n 1)
              if [ -n "$jar_file" ]; then
                cp "$jar_file" "/tmp/jars/${module_name}.jar"
                chmod 644 "/tmp/jars/${module_name}.jar"
                echo "Copied $jar_file to /tmp/jars/${module_name}.jar"
              else
                echo "Error: No suitable JAR found for $module_name"
                exit 1
              fi
            fi
          done
          
          echo "JAR files prepared:"
          ls -la /tmp/jars/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build and prepare JARs
        run: |
          echo "Building with Maven..."
          mvn -B clean package --file pom.xml
          
          echo "Setting up JAR files..."
          mkdir -p /tmp/workspace/jars
          
          # Copy JAR files to workspace
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              module_name=$(basename "$dir")
              jar_file=$(find "$dir/target" -maxdepth 1 -name "*.jar" \
                ! -name "original-*.jar" \
                ! -name "*-sources.jar" \
                ! -name "*-javadoc.jar" \
                -type f | head -n 1)
              if [ -n "$jar_file" ]; then
                cp "$jar_file" "/tmp/workspace/jars/${module_name}.jar"
                chmod 644 "/tmp/workspace/jars/${module_name}.jar"
                echo "Copied $jar_file to /tmp/workspace/jars/${module_name}.jar"
              else
                echo "Error: No suitable JAR found for $module_name"
                exit 1
              fi
            fi
          done
          
          echo "JAR files prepared in workspace:"
          ls -la /tmp/workspace/jars/

      - name: Verify workspace JARs
        run: |
          echo "Verifying JAR files in workspace..."
          ls -la /tmp/workspace/jars/
          
          # Verify required JARs exist
          missing_jars=0
          for module in api config gateway management stream core data; do
            if [ ! -f "/tmp/workspace/jars/openframe-${module}.jar" ]; then
              echo "Error: Missing JAR for openframe-${module}"
              missing_jars=1
            else
              echo "Found JAR for openframe-${module}:"
              ls -l "/tmp/workspace/jars/openframe-${module}.jar"
              file "/tmp/workspace/jars/openframe-${module}.jar"
            fi
          done
          
          if [ $missing_jars -eq 1 ]; then
            echo "Error: Some required JARs are missing"
            exit 1
          fi

      - name: Set up Docker environment
        run: |
          echo "Setting up Docker environment..."
          # Clean up disk space
          docker system prune -af
          df -h
          
          # Create registry data directory with proper permissions
          sudo mkdir -p /tmp/registry
          sudo chmod 777 /tmp/registry
          
          # Create Docker network for registry
          docker network create registry-net || true

          # Set up local registry with proper configuration and increased timeouts
          docker run -d --name registry \
            --network registry-net \
            -p 5000:5000 \
            -v /tmp/registry:/var/lib/registry \
            -e REGISTRY_STORAGE_DELETE_ENABLED=true \
            -e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \
            -e REGISTRY_HTTP_HEADERS_Access_Control_Allow_Origin='*' \
            -e REGISTRY_HTTP_HEADERS_Access_Control_Allow_Methods='HEAD,GET,OPTIONS,DELETE' \
            -e REGISTRY_HTTP_HEADERS_Access_Control_Allow_Headers='Authorization,Accept,Cache-Control' \
            -e REGISTRY_HTTP_HEADERS_Access_Control_Expose_Headers='Docker-Content-Digest' \
            -e REGISTRY_HTTP_NET_MAXPROCS=100 \
            -e REGISTRY_HTTP_NET_READTIMEOUT=600s \
            -e REGISTRY_HTTP_NET_WRITETIMEOUT=600s \
            -e REGISTRY_STORAGE_CACHE_BLOBDESCRIPTOR=inmemory \
            registry:2

          # Configure Docker to use insecure registry
          echo '{"insecure-registries": ["localhost:5000"]}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker || sudo service docker restart

          # Wait for Docker to restart
          echo "Waiting for Docker to restart..."
          sleep 10

          # Start registry container again after Docker restart
          docker start registry

          # Wait for registry to be ready with increased timeout and better health check
          echo "Waiting for registry to be ready..."
          max_attempts=90
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            if curl -s -f http://localhost:5000/v2/_catalog > /dev/null; then
              echo "Registry is ready"
              break
            fi
            echo "Waiting for registry... attempt $attempt/$max_attempts"
            sleep 2
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "Error: Registry failed to start after $max_attempts attempts"
            docker logs registry
            docker ps -a
            exit 1
          fi

          # Verify registry is accessible
          if ! curl -s http://localhost:5000/v2/_catalog > /dev/null; then
            echo "Error: Registry is not accessible after waiting"
            docker logs registry
            exit 1
          fi

          # Wait for registry to be ready with increased timeout and better health check
          echo "Waiting for registry to be ready..."
          max_attempts=90
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            if curl -s -f http://localhost:5000/v2/_catalog > /dev/null; then
              echo "Registry is ready"
              break
            fi
            echo "Waiting for registry... attempt $attempt/$max_attempts"
            sleep 2
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "Error: Registry failed to start after $max_attempts attempts"
            docker logs registry
            docker ps -a
            exit 1
          fi

          # Verify registry is accessible
          if ! curl -s http://localhost:5000/v2/_catalog > /dev/null; then
            echo "Error: Registry is not accessible after waiting"
            exit 1
          fi
          
          # Wait for registry to be ready with increased timeout and better health check
          echo "Waiting for registry to be ready..."
          for i in $(seq 1 120); do
            if curl -s -f http://localhost:5000/v2/_catalog > /dev/null; then
              echo "Registry is ready"
              break
            fi
            if [ $i -eq 120 ]; then
              echo "Error: Registry failed to start after 120 seconds"
              docker logs registry
              exit 1
            fi
            sleep 1
          done
          
          # Set up buildx for better caching
          docker buildx create --use
          docker buildx inspect --bootstrap
          
          # Create Docker network
          docker network create openframe-network --label com.docker.compose.network=openframe-network || true

      - name: Build and push infrastructure images
        run: |
          echo "Building and pushing infrastructure images..."
          
          # Build infrastructure images with buildx
          for service in mongodb cassandra nifi config api management ui stream gateway; do
            if [ -d "infrastructure/$service" ]; then
              service_dir="infrastructure/$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building infrastructure service $service..."
            elif [ -d "services/openframe-$service" ]; then
              service_dir="services/openframe-$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building OpenFrame service $service..."
            else
              echo "Error: Could not find build context for service $service"
              exit 1
            fi
            
            # Create temporary build context
            temp_context=$(mktemp -d)
            
            # Copy service files to build context
            cp -r "$service_dir"/* "$temp_context/"
            
            # If this is a Java service, copy the appropriate JAR file
            if [ -f "$service_dir/pom.xml" ]; then
              mkdir -p "$temp_context/target"
              module_name=$(basename "$service_dir")
              echo "Looking for JAR for module $module_name"
              if [ -f "/tmp/jars/${module_name}.jar" ]; then
                echo "Found JAR for $module_name"
                cp "/tmp/jars/${module_name}.jar" "$temp_context/target/app.jar"
              else
                echo "Error: Could not find JAR for $module_name"
                exit 1
              fi
              echo "Contents of target directory:"
              ls -la "$temp_context/target/"
            fi
            
            # List files in build context for debugging
            echo "Contents of build context:"
            ls -la "$temp_context"
            if [ -d "$temp_context/target" ]; then
              echo "Contents of target directory:"
              ls -la "$temp_context/target"
            fi
            
            # Build and push the image to local registry
            image_name="localhost:5000/openframe-$service:latest"
            if ! DOCKER_BUILDKIT=1 docker buildx build \
              --push \
              -t "$image_name" \
              -f "$dockerfile" \
              --cache-from "type=local,src=/tmp/.buildx-cache" \
              --cache-to "type=local,dest=/tmp/.buildx-cache" \
              --no-cache \
              "$temp_context"; then
              echo "Error: Failed to build $service image"
              rm -rf "$temp_context"
              exit 1
            fi
            
            # Verify image was pushed successfully
            if ! curl -s "http://localhost:5000/v2/openframe-$service/tags/list" | grep -q "latest"; then
              echo "Error: Failed to verify image push for $service"
              exit 1
            fi
            
            rm -rf "$temp_context"
          done
          
          # List all images in registry
          echo "Images in local registry:"
          curl -s http://localhost:5000/v2/_catalog

      - name: Deploy infrastructure services
        run: |
          docker compose -f docker-compose.openframe-infrastructure.yml up -d

      - name: Deploy Tactical RMM
        run: |
          docker compose -f docker-compose.openframe-tactical-rmm.yml up -d

      - name: Deploy Fleet MDM
        run: |
          docker compose -f docker-compose.openframe-fleet-mdm.yml up -d

      - name: Deploy Authentik
        run: |
          docker compose -f docker-compose.openframe-authentik.yml up -d

      - name: Register tools with OpenFrame API
        run: |
          echo "Registering tools with OpenFrame API..."
          # Add tool registration logic here

      - name: Verify deployment
        run: |
          ./scripts/test-public-endpoints.sh

      - name: Cleanup images and artifacts
        if: always()
        run: |
          echo "Cleaning up Docker images..."
          
          # Stop and remove registry container
          docker stop registry || true
          docker rm -v registry || true
          
          # Clean up registry data with proper permissions
          sudo rm -rf /tmp/registry || echo "Warning: Failed to remove registry directory" || true
          
          # Clean up all Docker resources
          docker system prune -af
          
          echo "Cleaning up build artifacts..."
          find . -type f -name "*.jar" -delete
          find . -type d -name "target" -exec rm -rf {} +
          
          echo "Verifying cleanup..."
          if docker ps -a | grep -q registry; then
            echo "Warning: Registry container still exists"
          fi
          if [ -d "/tmp/registry" ]; then
            echo "Warning: Registry data directory still exists"
          fi

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "Deployment failed, cleaning up services..."
          docker compose -f docker-compose.openframe-infrastructure.yml down
          docker compose -f docker-compose.openframe-tactical-rmm.yml down
          docker compose -f docker-compose.openframe-fleet-mdm.yml down
          docker compose -f docker-compose.openframe-authentik.yml down
          
          # Clean up any remaining images
          echo "Cleaning up remaining Docker images..."
          docker system prune -af
          
          echo "Cleanup completed"
