name: OpenFrame CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
  workflow_dispatch:

env:
  ORGANIZATION: flamingo-cx
  TIMESTAMP: ${{ github.event.repository.updated_at }}
  COMMIT_SHA: ${{ github.sha }}

permissions:
  contents: write
  packages: write
  actions: write
  pull-requests: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: |
          echo "Building with Maven..."
          mvn -B clean package --file pom.xml
          
          echo "Setting up JAR files..."
          mkdir -p /tmp/jars
          
          # Function to find and copy JAR files
          copy_jar() {
            local dir=$1
            local module_name=$(basename "$dir")
            echo "Processing module $module_name"
            
            # Find the JAR file (excluding original, sources, and javadoc JARs)
            local jar_file=$(find "$dir/target" -maxdepth 1 -name "*.jar" \
              ! -name "original-*.jar" \
              ! -name "*-sources.jar" \
              ! -name "*-javadoc.jar" \
              -type f | head -n 1)
            
            if [ -n "$jar_file" ]; then
              echo "Found JAR: $jar_file"
              cp "$jar_file" "/tmp/jars/${module_name}.jar"
              chmod 644 "/tmp/jars/${module_name}.jar"
              echo "Copied to /tmp/jars/${module_name}.jar"
              ls -l "/tmp/jars/${module_name}.jar"
            else
              echo "Error: No suitable JAR found for $module_name"
              echo "Contents of $dir/target:"
              ls -la "$dir/target/"
              return 1
            fi
          }
          
          # Process all modules
          echo "Processing all modules..."
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              if ! copy_jar "$dir"; then
                echo "Failed to process $dir"
                exit 1
              fi
            fi
          done
          
          echo "Final contents of /tmp/jars:"
          ls -la /tmp/jars/
          
          echo "Contents of centralized JAR directory:"
          ls -la /tmp/jars/

      - name: Verify JAR files
        run: |
          echo "Verifying JAR files..."
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              echo "=== Contents of $dir/target ==="
              ls -la "$dir/target/"*.jar || true
            fi
          done

      - name: Prepare JAR files for build
        run: |
          echo "Preparing JAR files for build..."
          mkdir -p /tmp/jars
          
          # Copy JAR files to a central location
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              module_name=$(basename "$dir")
              jar_file=$(find "$dir/target" -maxdepth 1 -name "*.jar" \
                ! -name "original-*.jar" \
                ! -name "*-sources.jar" \
                ! -name "*-javadoc.jar" \
                -type f | head -n 1)
              if [ -n "$jar_file" ]; then
                cp "$jar_file" "/tmp/jars/${module_name}.jar"
                chmod 644 "/tmp/jars/${module_name}.jar"
                echo "Copied $jar_file to /tmp/jars/${module_name}.jar"
              else
                echo "Error: No suitable JAR found for $module_name"
                exit 1
              fi
            fi
          done
          
          echo "JAR files prepared:"
          ls -la /tmp/jars/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build and prepare JARs
        run: |
          echo "Building with Maven..."
          # Add retries for Maven build
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Maven build attempt $attempt of $max_attempts"
            if mvn -B clean package --file pom.xml; then
              echo "Maven build successful"
              break
            fi
            attempt=$((attempt + 1))
            if [ $attempt -le $max_attempts ]; then
              echo "Maven build failed, retrying in 10 seconds..."
              sleep 10
            else
              echo "Maven build failed after $max_attempts attempts"
              exit 1
            fi
          done
          
          echo "Setting up JAR files..."
          mkdir -p /tmp/workspace/jars
          
          # Copy JAR files to workspace
          for dir in services/openframe-* libs/openframe-*; do
            if [ -d "$dir/target" ]; then
              module_name=$(basename "$dir")
              echo "Processing module $module_name..."
              
              # List target directory contents
              echo "Contents of $dir/target:"
              ls -la "$dir/target/"
              
              jar_file=$(find "$dir/target" -maxdepth 1 -name "*.jar" \
                ! -name "original-*.jar" \
                ! -name "*-sources.jar" \
                ! -name "*-javadoc.jar" \
                -type f | head -n 1)
              if [ -n "$jar_file" ]; then
                echo "Found JAR: $jar_file"
                cp "$jar_file" "/tmp/workspace/jars/${module_name}.jar"
                chmod 644 "/tmp/workspace/jars/${module_name}.jar"
                echo "Copied to /tmp/workspace/jars/${module_name}.jar"
                ls -l "/tmp/workspace/jars/${module_name}.jar"
              else
                echo "Error: No suitable JAR found for $module_name"
                echo "Contents of target directory:"
                ls -la "$dir/target/"
                exit 1
              fi
            fi
          done
          
          echo "JAR files prepared in workspace:"
          ls -la /tmp/workspace/jars/

      - name: Verify workspace JARs
        run: |
          echo "Verifying JAR files in workspace..."
          ls -la /tmp/workspace/jars/
          
          # Verify required JARs exist
          missing_jars=0
          for module in api config gateway management stream core data; do
            if [ ! -f "/tmp/workspace/jars/openframe-${module}.jar" ]; then
              echo "Error: Missing JAR for openframe-${module}"
              missing_jars=1
            else
              echo "Found JAR for openframe-${module}:"
              ls -l "/tmp/workspace/jars/openframe-${module}.jar"
              file "/tmp/workspace/jars/openframe-${module}.jar"
            fi
          done
          
          if [ $missing_jars -eq 1 ]; then
            echo "Error: Some required JARs are missing"
            exit 1
          fi

      - name: Set up Docker environment
        run: |
          echo "Setting up Docker environment..."
          # Clean up disk space
          docker system prune -af
          df -h
          
          # Configure Docker daemon for better performance
          echo '{
            "builder": {
              "gc": {
                "enabled": true,
                "defaultKeepStorage": "20GB"
              }
            },
            "experimental": true,
            "features": {
              "buildkit": true
            }
          }' | sudo tee /etc/docker/daemon.json
          
          # Restart Docker daemon to apply changes
          sudo systemctl restart docker || sudo service docker restart
          sleep 10
          
          # Wait for Docker daemon to be ready with better logging
          echo "Waiting for Docker daemon to be ready..."
          timeout 120s bash -c 'until docker info > /dev/null 2>&1; do echo "Docker daemon not ready yet..."; sleep 5; done'
          echo "Docker daemon is ready"
          docker info
          
          # Create Docker network
          echo "Creating Docker network..."
          docker network create openframe-network --label com.docker.compose.network=openframe-network || true
          
          # Set up buildx for better caching
          echo "Setting up Docker buildx..."
          docker buildx create --use
          docker buildx inspect --bootstrap
          
          # Show Docker system info
          echo "Docker system information:"
          docker system df
          df -h

      - name: Build infrastructure images
        run: |
          echo "Building infrastructure images..."
          
          # Function to build image with retries
          build_image() {
            local service="$1"
            local dockerfile="$2"
            local context="$3"
            local image_name="openframe-$service:latest"
            local max_attempts=3
            local attempt=1
            
            echo "Building $service image (attempt $attempt/$max_attempts)"
            while [ $attempt -le $max_attempts ]; do
              if DOCKER_BUILDKIT=1 docker build \
                -t "$image_name" \
                -f "$dockerfile" \
                --progress=plain \
                "$context"; then
                echo "Successfully built $image_name"
                return 0
              fi
              attempt=$((attempt + 1))
              if [ $attempt -le $max_attempts ]; then
                echo "Build failed for $service, retrying in 10 seconds..."
                sleep 10
              else
                echo "Build failed for $service after $max_attempts attempts"
                return 1
              fi
            done
          }
          
          # Process each service
          echo "Starting infrastructure builds..."
          for service in mongodb cassandra nifi config api management ui stream gateway; do
            echo "Processing service: $service"
            
            # Determine service directory and dockerfile location
            service_dir=""
            dockerfile=""
            
            if [ -d "infrastructure/$service" ]; then
              service_dir="infrastructure/$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building infrastructure service $service..."
            elif [ -d "services/openframe-$service" ]; then
              service_dir="services/openframe-$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building OpenFrame service $service..."
            else
              echo "Error: Could not find directory for service $service"
              continue
            fi

            # Verify dockerfile exists
            if [ ! -f "$dockerfile" ]; then
              echo "Error: Dockerfile not found at $dockerfile"
              continue
            fi
            if [ -d "infrastructure/$service" ]; then
              service_dir="infrastructure/$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building infrastructure service $service..."
            elif [ -d "services/openframe-$service" ]; then
              service_dir="services/openframe-$service"
              dockerfile="$service_dir/Dockerfile"
              echo "Building OpenFrame service $service..."
            else
              echo "Error: Could not find build context for service $service"
              exit 1
            fi
            
            # Create temporary build context with proper permissions
            temp_context=$(mktemp -d)
            chmod 755 "$temp_context"
            
            # Copy service files to build context
            cp -r "$service_dir"/* "$temp_context/"
            
            # If this is a Java service, copy the appropriate JAR file
            if [ -f "$service_dir/pom.xml" ]; then
              mkdir -p "$temp_context/target"
              module_name=$(basename "$service_dir")
              echo "Looking for JAR for module $module_name"
              if [ -f "/tmp/workspace/jars/${module_name}.jar" ]; then
                echo "Found JAR for $module_name"
                cp "/tmp/workspace/jars/${module_name}.jar" "$temp_context/target/app.jar"
              else
                echo "Error: Could not find JAR for $module_name"
                exit 1
              fi
              echo "Contents of target directory:"
              ls -la "$temp_context/target/"
            fi
            
            # List files in build context for debugging
            echo "Contents of build context:"
            ls -la "$temp_context"
            if [ -d "$temp_context/target" ]; then
              echo "Contents of target directory:"
              ls -la "$temp_context/target"
            fi
            
            # Build the image
            if ! build_image "$service" "$dockerfile" "$temp_context"; then
              echo "Failed to build $service image"
              rm -rf "$temp_context"
              exit 1
            fi
            
            # Clean up build context
            rm -rf "$temp_context"
            
            # Verify image exists
            if ! docker image inspect "openframe-$service:latest" >/dev/null 2>&1; then
              echo "Error: Image openframe-$service:latest not found after build"
              exit 1
            fi
            
            # Verify image was built successfully
            if ! docker image inspect "$image_name" > /dev/null 2>&1; then
              echo "Error: Failed to verify image build for $service"
              exit 1
            fi
            
            rm -rf "$temp_context"
          done
          
          # List all local images
          echo "Local Docker images:"
          docker images | grep openframe

      - name: Deploy infrastructure services
        run: |
          echo "Starting infrastructure services..."
          docker compose -f docker-compose.openframe-infrastructure.yml up -d
          
          # Wait for services to be ready
          timeout 300s bash -c 'until docker compose -f docker-compose.openframe-infrastructure.yml ps | grep -q "Up"; do echo "Waiting for services to start..."; sleep 5; done'
          
          # Show service status
          docker compose -f docker-compose.openframe-infrastructure.yml ps
          docker compose -f docker-compose.openframe-infrastructure.yml logs --tail=100

      - name: Deploy Tactical RMM
        run: |
          docker compose -f docker-compose.openframe-tactical-rmm.yml up -d

      - name: Deploy Fleet MDM
        run: |
          docker compose -f docker-compose.openframe-fleet-mdm.yml up -d

      - name: Deploy Authentik
        run: |
          docker compose -f docker-compose.openframe-authentik.yml up -d

      - name: Register tools with OpenFrame API
        run: |
          echo "Registering tools with OpenFrame API..."
          # Add tool registration logic here

      - name: Verify deployment
        run: |
          ./scripts/test-public-endpoints.sh

      - name: Cleanup images and artifacts
        if: always()
        run: |
          echo "Cleaning up Docker images..."
          
          # Clean up all Docker resources
          docker system prune -af
          
          echo "Cleaning up build artifacts..."
          find . -type f -name "*.jar" -delete
          find . -type d -name "target" -exec rm -rf {} +

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "Deployment failed, cleaning up services..."
          docker compose -f docker-compose.openframe-infrastructure.yml down
          docker compose -f docker-compose.openframe-tactical-rmm.yml down
          docker compose -f docker-compose.openframe-fleet-mdm.yml down
          docker compose -f docker-compose.openframe-authentik.yml down
          
          # Clean up any remaining images
          echo "Cleaning up remaining Docker images..."
          docker system prune -af
          
          echo "Cleanup completed"
