package templates

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/pterm/pterm"
)

const (
	// CLI_GENERATED_MARKER is the comment marker we add to files generated by the CLI
	CLI_GENERATED_MARKER = "# Generated by OpenFrame CLI configuration wizard"
	// CLI_GENERATED_TIMESTAMP_PREFIX is used to track when files were generated
	CLI_GENERATED_TIMESTAMP_PREFIX = "# Generated at: "
	// BACKUP_SUFFIX is added to backup files
	BACKUP_SUFFIX = ".cli-backup"
)

// FileBackup represents a file backup operation
type FileBackup struct {
	OriginalPath string
	BackupPath   string
	ContentOnly  bool // If true, we only store content in memory
	OriginalContent []byte
	FileExisted  bool
}

// FileCleanup handles backup and restore of files modified by CLI
type FileCleanup struct {
	backups []FileBackup
}

// NewFileCleanup creates a new file cleanup manager
func NewFileCleanup() *FileCleanup {
	return &FileCleanup{
		backups: make([]FileBackup, 0),
	}
}

// BackupFile creates a backup of a file before we modify it
func (fc *FileCleanup) BackupFile(filePath string, useMemoryOnly bool) error {
	backup := FileBackup{
		OriginalPath: filePath,
		ContentOnly:  useMemoryOnly,
		FileExisted:  false,
	}

	// Check if file exists
	if _, err := os.Stat(filePath); err == nil {
		backup.FileExisted = true
		
		if useMemoryOnly {
			// Store content in memory
			content, err := os.ReadFile(filePath)
			if err != nil {
				return fmt.Errorf("failed to read file for backup: %w", err)
			}
			backup.OriginalContent = content
		} else {
			// Create physical backup file
			backup.BackupPath = filePath + BACKUP_SUFFIX
			if err := fc.copyFile(filePath, backup.BackupPath); err != nil {
				return fmt.Errorf("failed to create backup file: %w", err)
			}
		}
	} else if !os.IsNotExist(err) {
		return fmt.Errorf("failed to check file status: %w", err)
	}

	fc.backups = append(fc.backups, backup)
	return nil
}

// RestoreFiles restores all backed up files to their original state
func (fc *FileCleanup) RestoreFiles(verbose bool) error {
	if len(fc.backups) == 0 {
		if verbose {
			pterm.Info.Println("No files to restore")
		}
		return nil
	}

	restoredCount := 0
	for _, backup := range fc.backups {
		if err := fc.restoreFile(backup, verbose); err != nil {
			if verbose {
				pterm.Warning.Printf("Failed to restore %s: %v\n", backup.OriginalPath, err)
			}
			continue
		}
		restoredCount++
	}

	if restoredCount > 0 {
		pterm.Success.Printf("✅ Restored %d file(s) to original state\n", restoredCount)
	}

	// Clean up physical backup files
	fc.cleanupBackupFiles(verbose)

	return nil
}

// restoreFile restores a single file from backup
func (fc *FileCleanup) restoreFile(backup FileBackup, verbose bool) error {
	if backup.FileExisted {
		if backup.ContentOnly {
			// Restore from memory
			if err := os.WriteFile(backup.OriginalPath, backup.OriginalContent, 0644); err != nil {
				return fmt.Errorf("failed to restore file from memory: %w", err)
			}
		} else {
			// Restore from backup file
			if err := fc.copyFile(backup.BackupPath, backup.OriginalPath); err != nil {
				return fmt.Errorf("failed to restore from backup file: %w", err)
			}
		}
		if verbose {
			pterm.Success.Printf("✓ Restored original: %s\n", backup.OriginalPath)
		}
	} else {
		// File didn't exist originally, remove it
		if err := os.Remove(backup.OriginalPath); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("failed to remove file that didn't exist originally: %w", err)
		}
		if verbose {
			pterm.Success.Printf("✓ Removed generated file: %s\n", backup.OriginalPath)
		}
	}

	return nil
}

// cleanupBackupFiles removes physical backup files
func (fc *FileCleanup) cleanupBackupFiles(verbose bool) {
	for _, backup := range fc.backups {
		if !backup.ContentOnly && backup.BackupPath != "" {
			if err := os.Remove(backup.BackupPath); err != nil && !os.IsNotExist(err) {
				if verbose {
					pterm.Warning.Printf("Failed to remove backup file %s: %v\n", backup.BackupPath, err)
				}
			}
		}
	}
}

// copyFile copies a file from src to dst
func (fc *FileCleanup) copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	// Create destination directory if it doesn't exist
	if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil {
		return err
	}

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	return err
}

// AddCLIMarkerToFile adds our generation marker to the beginning of a file
func AddCLIMarkerToFile(filePath, originalContent string) string {
	timestamp := time.Now().Format(time.RFC3339)
	
	header := fmt.Sprintf(`%s
%s%s
# =============================================================================
# DO NOT EDIT - This file is auto-generated and will be cleaned up after installation
# =============================================================================

`, CLI_GENERATED_MARKER, CLI_GENERATED_TIMESTAMP_PREFIX, timestamp)

	return header + originalContent
}

// GetSafeFileName creates a filename that indicates it's temporary/generated
func GetSafeFileName(baseName string) string {
	dir := filepath.Dir(baseName)
	filename := filepath.Base(baseName)
	ext := filepath.Ext(filename)
	nameWithoutExt := strings.TrimSuffix(filename, ext)
	
	// Add timestamp to make it unique and indicate it's temporary
	timestamp := time.Now().Format("20060102-150405")
	safeFilename := fmt.Sprintf("%s-generated-%s%s", nameWithoutExt, timestamp, ext)
	
	return filepath.Join(dir, safeFilename)
}